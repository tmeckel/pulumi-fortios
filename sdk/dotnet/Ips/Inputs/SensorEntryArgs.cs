// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Pulumiverse.Fortios.Ips.Inputs
{

    public sealed class SensorEntryArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Action taken with traffic in which signatures are detected. Valid values: `pass`, `block`, `reset`, `default`.
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// Applications to be protected. set application ? lists available applications. all includes all applications. other includes all unlisted applications.
        /// </summary>
        [Input("application")]
        public Input<string>? Application { get; set; }

        [Input("cves")]
        private InputList<Inputs.SensorEntryCfeArgs>? _cves;

        /// <summary>
        /// List of CVE IDs of the signatures to add to the sensor The structure of `cve` block is documented below.
        /// </summary>
        public InputList<Inputs.SensorEntryCfeArgs> Cves
        {
            get => _cves ?? (_cves = new InputList<Inputs.SensorEntryCfeArgs>());
            set => _cves = value;
        }

        /// <summary>
        /// Signature default action filter. Valid values: `all`, `pass`, `block`.
        /// </summary>
        [Input("defaultAction")]
        public Input<string>? DefaultAction { get; set; }

        /// <summary>
        /// Signature default status filter. Valid values: `all`, `enable`, `disable`.
        /// </summary>
        [Input("defaultStatus")]
        public Input<string>? DefaultStatus { get; set; }

        [Input("exemptIps")]
        private InputList<Inputs.SensorEntryExemptIpArgs>? _exemptIps;

        /// <summary>
        /// Traffic from selected source or destination IP addresses is exempt from this signature. The structure of `exempt_ip` block is documented below.
        /// </summary>
        public InputList<Inputs.SensorEntryExemptIpArgs> ExemptIps
        {
            get => _exemptIps ?? (_exemptIps = new InputList<Inputs.SensorEntryExemptIpArgs>());
            set => _exemptIps = value;
        }

        /// <summary>
        /// Rule ID in IPS database (0 - 4294967295).
        /// </summary>
        [Input("id")]
        public Input<int>? Id { get; set; }

        /// <summary>
        /// Filter by signature last modified date. Formats: before &lt;date&gt;, after &lt;date&gt;, between &lt;start-date&gt; &lt;end-date&gt;.
        /// </summary>
        [Input("lastModified")]
        public Input<string>? LastModified { get; set; }

        /// <summary>
        /// Protect client or server traffic.
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// Enable/disable logging of signatures included in filter. Valid values: `disable`, `enable`.
        /// </summary>
        [Input("log")]
        public Input<string>? Log { get; set; }

        /// <summary>
        /// Enable/disable logging of attack context: URL buffer, header buffer, body buffer, packet buffer. Valid values: `disable`, `enable`.
        /// </summary>
        [Input("logAttackContext")]
        public Input<string>? LogAttackContext { get; set; }

        /// <summary>
        /// Enable/disable packet logging. Enable to save the packet that triggers the filter. You can download the packets in pcap format for diagnostic use. Valid values: `disable`, `enable`.
        /// </summary>
        [Input("logPacket")]
        public Input<string>? LogPacket { get; set; }

        /// <summary>
        /// Operating systems to be protected.  all includes all operating systems. other includes all unlisted operating systems.
        /// </summary>
        [Input("os")]
        public Input<string>? Os { get; set; }

        /// <summary>
        /// Protocols to be examined. set protocol ? lists available protocols. all includes all protocols. other includes all unlisted protocols.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// Quarantine method. Valid values: `none`, `attacker`.
        /// </summary>
        [Input("quarantine")]
        public Input<string>? Quarantine { get; set; }

        /// <summary>
        /// Duration of quarantine. (Format ###d##h##m, minimum 1m, maximum 364d23h59m, default = 5m). Requires quarantine set to attacker.
        /// </summary>
        [Input("quarantineExpiry")]
        public Input<string>? QuarantineExpiry { get; set; }

        /// <summary>
        /// Enable/disable quarantine logging. Valid values: `disable`, `enable`.
        /// </summary>
        [Input("quarantineLog")]
        public Input<string>? QuarantineLog { get; set; }

        /// <summary>
        /// Count of the rate.
        /// </summary>
        [Input("rateCount")]
        public Input<int>? RateCount { get; set; }

        /// <summary>
        /// Duration (sec) of the rate.
        /// </summary>
        [Input("rateDuration")]
        public Input<int>? RateDuration { get; set; }

        /// <summary>
        /// Rate limit mode. Valid values: `periodical`, `continuous`.
        /// </summary>
        [Input("rateMode")]
        public Input<string>? RateMode { get; set; }

        /// <summary>
        /// Track the packet protocol field. Valid values: `none`, `src-ip`, `dest-ip`, `dhcp-client-mac`, `dns-domain`.
        /// </summary>
        [Input("rateTrack")]
        public Input<string>? RateTrack { get; set; }

        [Input("rules")]
        private InputList<Inputs.SensorEntryRuleArgs>? _rules;

        /// <summary>
        /// Identifies the predefined or custom IPS signatures to add to the sensor. The structure of `rule` block is documented below.
        /// </summary>
        public InputList<Inputs.SensorEntryRuleArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<Inputs.SensorEntryRuleArgs>());
            set => _rules = value;
        }

        /// <summary>
        /// Relative severity of the signature, from info to critical. Log messages generated by the signature include the severity.
        /// </summary>
        [Input("severity")]
        public Input<string>? Severity { get; set; }

        /// <summary>
        /// Status of the signatures included in filter. default enables the filter and only use filters with default status of enable. Filters with default status of disable will not be used. Valid values: `disable`, `enable`, `default`.
        /// </summary>
        [Input("status")]
        public Input<string>? Status { get; set; }

        [Input("vulnTypes")]
        private InputList<Inputs.SensorEntryVulnTypeArgs>? _vulnTypes;

        /// <summary>
        /// List of signature vulnerability types to filter by. The structure of `vuln_type` block is documented below.
        /// </summary>
        public InputList<Inputs.SensorEntryVulnTypeArgs> VulnTypes
        {
            get => _vulnTypes ?? (_vulnTypes = new InputList<Inputs.SensorEntryVulnTypeArgs>());
            set => _vulnTypes = value;
        }

        public SensorEntryArgs()
        {
        }
        public static new SensorEntryArgs Empty => new SensorEntryArgs();
    }
}
